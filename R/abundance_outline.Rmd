---
title: "NIMBLE Abundance"
author: "Colin Lewis-Beck"
date: "June 20, 2017"
output: pdf_document
---

For Abundance Models the package unmarked takes 3 data objects: a matrix with the observed counts where rows are sites (R) and columns are visits (T); a matrix of site level covariates (rows are sites, columns are site level variables); and a list of site level covariates where each matrix within the list corresponds to one covariate, and is an R x T matrix.

As an example, below is the mallard data set from the unmarked package.  Using TidyR, we can put the data into long format where each row is an observation, and each column is a variable.  

```{r, echo=FALSE, message = FALSE}
#Abundance
library(unmarked)
library(reshape2)
library(tidyr)
library(dplyr)

#Data from Unmarked Packcage
y <- as.data.frame(mallard.y)
sitecov <- as.data.frame(mallard.site)
obscov <- mallard.obs

visitid <- colnames(y)

#Make Site ID Variable
y$site <- as.numeric(rownames(y))
sitecov$site <- as.numeric(rownames(sitecov))

long.y <- gather(y, visit, count, 1:3)

site.merge <- left_join(long.y, sitecov, by = "site")

#Add Obs Level Covariates
evel = as.data.frame(obscov$ivel)
colnames(evel) <- visitid
evel$site <- as.numeric(rownames(evel))
long.evel <- gather(evel, visit, ivel, 1:3)

date = as.data.frame(obscov$date)
colnames(date) <- visitid
date$site <- as.numeric(rownames(date))
long.date <- gather(date, visit, date, 1:3)


out <- left_join(site.merge, long.evel, by = c("site", "visit"))
longdata <- left_join(out, long.date, by = c("site", "visit"))
head(longdata)

```

However, I am not sure whether this data structure would help for an abundance.nim function: especially since the data needs to be passed to nimbleModel as a list.   It seems like the structure of abundance.nim should be as follows.  Let's assume we have R sites and T measurements, C site covariates, and O observation level covariates.  The structure of the function is similar to the package unmarked.

```
abundance.nim <- function(observation formula, site formula, Observed Counts (RxT matrix), 
Observation Covarites (list of length O of RxT matrices for each covariate), Site Covariates (R x C matrix), returnCode = FALSE, dropbase = FALSE, priors = "Normal", niter = 10000, burnin = 1000, initmcmc = 1, chains = 1)
```

As a toy example, the function would function as follows:

```
mod1 <- abundance.nim(~ 1 + date, ~ 1 + evel + A, y = y, ObsCov = list(date = date), Site Covariates = list(evel, A))
```

The function would generate the following code:

latent = N[1:R] ~ nim_glm(1 + evel[1:R] + A[1:nlevels], factors = "A", family = pois, link = log, priors = priors)    
obs = y[1:R, 1:T] ~ nim_glm(1 + date[1:R, 1:T], factors = "None", family = binom, link = logit, priors = priors)    

Then we use nim_glm expansion Module 

```
latent.expand <- nim_glm$process(latent)    
obs.expand <- nim_glm$process(obs)    
```

This generates:  

for (i in 1:R){    
  N[i] ~ dpoi(lambda[i])     
  }
      
 lambda[i] <- lmPred(1 + evel[1:R] + A[1:nlevels], priors = priors, factors = "A", link = log)     
  
for (i in 1:R){     
     for (t in 1:T){     
    y[i,j] ~ dbinom(p(i,j), N[i])    
  }    
}   

 p(i,j) <- lmPred(1 + date[1:R, 1:T], priors = priors, factors = "None", link = logit)

```
lmPred$process(latent.expand$LHS, latent.expand$RHS)    
lmPred$process(obs.expand$LHS, obs.expand$RHS)    
```
This expands the linear predictors 

for (i in 1:R){   
  log(lambda[i]) <- l.intercept + evel*evel[i] + A.effect[A[i]]   
  }
  
for (i in 1:R){   
  for (t in 1:T){    
    logit(p(i,j)) <- p.intercept + date * date[i,j]     
  }
}

l.intercept ~ dnorm(0, 100)  
p.intercept ~ dnorm(0, 100)  
ym ~ dnorm(0, 100)   
xm ~ dnorm(0, 100)  
  for (i in 1:nlevels){     
    A.effect[i] ~ dnorm(0, 100)     
}  

All these code pieces would need to be grouped together into one final code object.

I think passing the data in seperate pieces rather than constructing a tidy data object will make the data easier to pass to nimbleModel.  Once the initial values are generated, something like the following will make the nimbleModel.

nimMod.obj <- nimbleModel(code = full.expand, inits = values, constants = list(date = date, A = A, evel = evel), data = y)

Then a function can be called to runMCMC and return the final results and BUGS code.    

Note: random slope and intercepts can be included with (1|A) or (xm|A).  One key piece will be to be able to generated the nested loops and be able to extract the two formula objects from the initial function.


